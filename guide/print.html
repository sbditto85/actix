<!DOCTYPE HTML>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <title>Actix</title>
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="Actix framework guide">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <base href="">

        <link rel="stylesheet" href="book.css">
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

        <link rel="shortcut icon" href="favicon.png">

        <!-- Font Awesome -->
        <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css">

        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme -->
        

        

        <!-- Fetch Clipboard.js from CDN but have a local fallback -->
        <script src="https://cdn.jsdelivr.net/clipboard.js/1.6.1/clipboard.min.js"></script>
        <script>
            if (typeof Clipboard == 'undefined') {
                document.write(unescape("%3Cscript src='clipboard.min.js'%3E%3C/script%3E"));
            }
        </script>

    </head>
    <body class="light">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { } 
            if (theme === null || theme === undefined) { theme = 'light'; }
            document.body.className = theme;
            document.querySelector('html').className = theme;
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            document.querySelector('html').classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <ol class="chapter"><li><a href="qs_01.html"><strong aria-hidden="true">1.</strong> Quickstart</a></li><li><a href="qs_02.html"><strong aria-hidden="true">2.</strong> Getting Started</a></li><li><a href="qs_03.html"><strong aria-hidden="true">3.</strong> Actor</a></li><li><a href="qs_04.html"><strong aria-hidden="true">4.</strong> Address</a></li><li><a href="qs_05.html"><strong aria-hidden="true">5.</strong> Context</a></li><li><a href="qs_06.html"><strong aria-hidden="true">6.</strong> Arbiter</a></li><li><a href="qs_07.html"><strong aria-hidden="true">7.</strong> SyncArbiter</a></li><li><a href="qs_08.html"><strong aria-hidden="true">8.</strong> Stream</a></li><li><a href="qs_09.html"><strong aria-hidden="true">9.</strong> IO helpers</a></li><li><a href="qs_10.html"><strong aria-hidden="true">10.</strong> Supervisor</a></li><li><a href="qs_11.html"><strong aria-hidden="true">11.</strong> Registry</a></li><li><a href="qs_12.html"><strong aria-hidden="true">12.</strong> Helper actors</a></li></ol>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar" class="menu-bar">
                    <div id="menu-bar-sticky-container">
                        <div class="left-buttons">
                            <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                                <i class="fa fa-bars"></i>
                            </button>
                            <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                                <i class="fa fa-paint-brush"></i>
                            </button>
                            <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                                <li role="none"><button role="menuitem" class="theme" id="light">Light <span class="default">(default)</span></button></li>
                                <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                            </ul>
                        </div>

                        <h1 class="menu-title">Actix</h1>

                        <div class="right-buttons">
                            <a href="print.html" title="Print this book" aria-label="Print this book">
                                <i id="print-button" class="fa fa-print"></i>
                            </a>
                        </div>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <a class="header" href="print.html#quick-start" id="quick-start"><h1>Quick start</h1></a>
<p>Before you can start writing a actix application, you’ll need a version of Rust installed.
We recommend you use rustup to install or configure such a version.</p>
<a class="header" href="print.html#install-rust" id="install-rust"><h2>Install Rust</h2></a>
<p>Before we begin, we need to install Rust using the <a href="https://www.rustup.rs/">rustup</a> installer:</p>
<pre><code class="language-bash">curl https://sh.rustup.rs -sSf | sh
</code></pre>
<p>If you already have rustup installed, run this command to ensure you have the latest version of Rust:</p>
<pre><code class="language-bash">rustup update
</code></pre>
<p>Actix framework requires rust version 1.21 and up.</p>
<a class="header" href="print.html#running-examples" id="running-examples"><h2>Running Examples</h2></a>
<p>The fastest way to start experimenting with actix is to clone the actix repository
and run the included examples in the examples/ directory. The following set of
commands runs the <code>ping</code> example:</p>
<pre><code class="language-bash">git clone https://github.com/actix/actix
cargo run --example ping
</code></pre>
<p>Check <a href="https://github.com/actix/actix/tree/master/examples">examples/</a> directory for more examples.</p>
<a class="header" href="print.html#getting-started" id="getting-started"><h1>Getting Started</h1></a>
<p>Let’s create and run our first actix application. We’ll create a new Cargo project
that depends on actix and then run the application.</p>
<p>In previous section we already installed required rust version. Now let's create new cargo projects.</p>
<a class="header" href="print.html#ping-actor" id="ping-actor"><h2>Ping actor</h2></a>
<p>Let’s write our first actix application! Start by creating a new binary-based
Cargo project and changing into the new directory:</p>
<pre><code class="language-bash">cargo new actor-ping --bin
cd actor-ping
</code></pre>
<p>Now, add actix as dependencies of your project by ensuring your Cargo.toml
contains the following:</p>
<pre><code class="language-toml">[dependencies]
actix = &quot;0.5&quot;
</code></pre>
<p>Let's create an actor that will accept <code>Ping</code> message and respond with number of pings processed.</p>
<p>An actor is a type that implements <code>Actor</code> trait:</p>
<pre><pre class="playpen"><code class="language-rust"># extern crate actix;
use actix::prelude::*;

struct MyActor {
    count: usize,
}

impl Actor for MyActor {
    type Context = Context&lt;Self&gt;;
}

# fn main() {}
</code></pre></pre>
<p>Each actor has execution context, for <code>MyActor</code> we are going to use <code>Context&lt;A&gt;</code>. More information
on actor contexts is available in next section.</p>
<p>Now we need to define <code>Message</code> that actor needs to accept. Message could be any type
that implement <code>Message</code> trait.</p>
<pre><pre class="playpen"><code class="language-rust"># extern crate actix;
use actix::prelude::*;

struct Ping(usize);

impl Message for Ping {
    type Result = usize;
}

# fn main() {}
</code></pre></pre>
<p>Main purpose of the <code>Message</code> trait is to define result type. <code>Ping</code> message defines
<code>usize</code> result, which indicates that any actor that can accept <code>Ping</code> message needs to
return <code>usize</code> value.</p>
<p>And finally, we need to declare that our actor <code>MyActor</code> can accept <code>Ping</code> and handle it.
To do this, actor needs to implement <code>Handler&lt;Ping&gt;</code> trait.</p>
<pre><pre class="playpen"><code class="language-rust"># extern crate actix;
# use actix::prelude::*;
#
# struct MyActor {
#    count: usize,
# }
# impl Actor for MyActor {
#     type Context = Context&lt;Self&gt;;
# }
#
# struct Ping(usize);
#
# impl Message for Ping {
#    type Result = usize;
# }

impl Handler&lt;Ping&gt; for MyActor {
    type Result = usize;
    
    fn handle(&amp;mut self, msg: Ping, ctx: &amp;mut Context&lt;Self&gt;) -&gt; Self::Result {
        self.count += msg.0;
        
        self.count
    }
}

# fn main() {}
</code></pre></pre>
<p>That is it. Now we just need to start our actor and send message to it.
Start procedure depends on actor's context implementation. In our can we use
<code>Context&lt;A&gt;</code> which is tokio/future based. We can start it with <code>Actor::start()</code>
or <code>Actor::create()</code>. First is used if actor instance could be create immediately.
Second method is used in case if we need access to context object before we can create
actor instance. In case of <code>MyActor</code> actor we can use <code>start()</code> method.</p>
<p>All communications with actors go through an address. You can <code>do_send</code> a message
without waiting for a response, or <code>send</code> an actor with specific message.
Both <code>start()</code> and <code>create()</code> methods returns address object.</p>
<p>In following example we are going to create <code>MyActor</code> actor and send one message.</p>
<pre><pre class="playpen"><code class="language-rust"># extern crate actix;
# extern crate futures;
# use futures::Future;
# use actix::prelude::*;
# struct MyActor {
#    count: usize,
# }
# impl Actor for MyActor {
#     type Context = Context&lt;Self&gt;;
# }
#
# struct Ping(usize);
#
# impl Message for Ping {
#    type Result = usize;
# }
# impl Handler&lt;Ping&gt; for MyActor {
#     type Result = usize;
#
#     fn handle(&amp;mut self, msg: Ping, ctx: &amp;mut Context&lt;Self&gt;) -&gt; Self::Result {
#         self.count += msg.0;
#         self.count
#     }
# }
#
fn main() {
    let system = System::new(&quot;test&quot;);

    // start new actor
    let addr: Addr&lt;Unsync, _&gt; = MyActor{count: 10}.start();

    // send message and get future for result
    let res = addr.send(Ping(10));
    
    Arbiter::handle().spawn(
        res.map(|res| {
            # Arbiter::system().do_send(actix::msgs::SystemExit(0));
            println!(&quot;RESULT: {}&quot;, res == 20);
        })
        .map_err(|_| ()));

    system.run();
}
</code></pre></pre>
<p>Ping example is available in <a href="https://github.com/actix/actix/tree/master/examples/">examples directory</a>.</p>
<a class="header" href="print.html#actor" id="actor"><h1>Actor</h1></a>
<p>Actix is a rust library providing a framework for developing concurrent applications.</p>
<p>Actix is built on the <a href="https://en.wikipedia.org/wiki/Actor_model">Actor Model</a> which
allows applications to be written as a group of independently executing but cooperating
&quot;Actors&quot; which communicate via messages. Actors are objects which encapsulate
state and behavior and run within the <em>Actor System</em> provided by the actix library.</p>
<p>Actors run within specific execution context <a href="../actix/struct.Context.html"><em>Context<A></em></a>.
Context object is available only during execution. Each actor has separate
execution context. Also execution context controls lifecycle of an actor.</p>
<p>Actors communicate exclusively by exchanging messages. Sender actor can
wait for response. Actors are not referenced directly, but by different
types of addresses. Non thread safe <a href="../actix/struct.Addr.html"><em>Addr&lt;Unsync, A&gt;</em></a> or
thread safe address <a href="../actix/struct.Syn.html"><em>Addr&lt;Syn, A&gt;</em></a></p>
<p>Any rust type can be an actor, it needs to implement <a href="../actix/trait.Actor.html"><em>Actor</em></a> trait.</p>
<p>To be able to handle specific message actor has to provide
<a href="../actix/trait.Handler.html"><em>Handler<M></em></a> implementation for this message. All messages
are statically typed. Message could be handled in asynchronous fashion.
Actor can spawn other actors or add futures or streams to execution context.
Actor trait provides several methods that allow to control actor lifecycle.</p>
<a class="header" href="print.html#actor-lifecycle" id="actor-lifecycle"><h2>Actor lifecycle</h2></a>
<a class="header" href="print.html#started" id="started"><h3>Started</h3></a>
<p>Actor is always starts in <code>Started</code> state, during this state actor's <code>started()</code>
method get called. <code>Actor</code> trait provides default implementation for this method.
Actor context is available during this state, actor can start more actors or register
async streams or do any other required configuration.</p>
<a class="header" href="print.html#running" id="running"><h3>Running</h3></a>
<p>After Actor's method <code>started()</code> get called, actor transitions to <code>Running</code> state.
Actor can stay in <code>running</code> state indefinitely long.</p>
<a class="header" href="print.html#stopping" id="stopping"><h3>Stopping</h3></a>
<p>Actor execution state changes to <code>stopping</code> state in following situations,</p>
<ul>
<li><code>Context::stop</code> get called by actor itself</li>
<li>all addresses to the actor get dropped. i.e. no other actor reference it.</li>
<li>no evented objects are registered in context.</li>
</ul>
<p>Actor could restore from <code>stopping</code> state to <code>running</code> state by creating new
address or adding evented object, and by returning <code>Running::Continue</code> value.</p>
<p>If actor changed state to a <code>stopping</code> state because of <code>Context::stop()</code> get called
then context immediately stops processing incoming messages and calls
<code>Actor::stopping()</code> method. If actor does not restore back to a <code>running</code> state, all
unprocessed messages get dropped.</p>
<p>By default this method returns <code>Running::Stop</code> which confirms stop operation.</p>
<a class="header" href="print.html#stopped" id="stopped"><h3>Stopped</h3></a>
<p>If actor does not modify execution context during stopping state, actor state changes
to <code>Stopped</code>. This state is considered final and at this point actor get dropped.</p>
<a class="header" href="print.html#message" id="message"><h2>Message</h2></a>
<p>An Actor communicates with another Actors by sending messages. In actix all
messages are typed. Message could be any rust type which implements
<a href="../actix/trait.Actor.html">Message</a> trait. <em>Message::Result</em> defines return type.
Let's define a simple <code>Ping</code> message, an actor which will accept this message needs to return
<code>io::Result&lt;bool&gt;</code>.</p>
<pre><pre class="playpen"><code class="language-rust"># extern crate actix;
use std::io;
use actix::prelude::*;

struct Ping;

impl Message for Ping {
    type Result = Result&lt;bool, io::Error&gt;;
}

# fn main() {}
</code></pre></pre>
<a class="header" href="print.html#spawning-an-actor" id="spawning-an-actor"><h2>Spawning an actor</h2></a>
<p>How to start an actor depends on it's context.Spawning a new async actor
is achieved via the <code>start</code> and <code>create</code> methods of
the <a href="../actix/trait.Actor.html">Actor</a> trait. It provides several different ways of
creating actors, for details check the docs.</p>
<a class="header" href="print.html#complete-example" id="complete-example"><h2>Complete example</h2></a>
<pre><pre class="playpen"><code class="language-rust"># extern crate actix;
# extern crate futures;
use std::io;
use actix::prelude::*;
use futures::Future;

/// Define message
struct Ping;

impl Message for Ping {
    type Result = Result&lt;bool, io::Error&gt;;
}


// Define actor
struct MyActor;

// Provide Actor implementation for our actor
impl Actor for MyActor {
    type Context = Context&lt;Self&gt;;
    
    fn started(&amp;mut self, ctx: &amp;mut Context&lt;Self&gt;) {
       println!(&quot;Actor is alive&quot;);
    }
    
    fn stopped(&amp;mut self, ctx: &amp;mut Context&lt;Self&gt;) {
       println!(&quot;Actor is stopped&quot;);
    }
}

/// Define handler for `Ping` message
impl Handler&lt;Ping&gt; for MyActor {
    type Result = Result&lt;bool, io::Error&gt;;

    fn handle(&amp;mut self, msg: Ping, ctx: &amp;mut Context&lt;Self&gt;) -&gt; Self::Result {
        println!(&quot;Ping received&quot;);
        
        Ok(true)
    }
}

fn main() {
    let sys = System::new(&quot;example&quot;);
    
    // Start MyActor in current thread
    let addr: Addr&lt;Unsync, _&gt; = MyActor.start();
    
    // Send Ping message.
    // send() message returns Future object, that resolves to message result
    let result = addr.send(Ping);

    // spawn future to reactor
    Arbiter::handle().spawn(
        result.map(|res| {
            match res {
                Ok(result) =&gt; println!(&quot;Got result: {}&quot;, result),
                Err(err) =&gt; println!(&quot;Got error: {}&quot;, err),
            }
#           Arbiter::system().do_send(actix::msgs::SystemExit(0));
        })
        .map_err(|e| {
            println!(&quot;Actor is probably died: {}&quot;, e);
        }));
    
    sys.run();
}
</code></pre></pre>
<a class="header" href="print.html#wip-address" id="wip-address"><h1>[WIP] Address</h1></a>
<a class="header" href="print.html#wip-context" id="wip-context"><h1>[WIP] Context</h1></a>
<a class="header" href="print.html#wip-arbiter" id="wip-arbiter"><h1>[WIP] Arbiter</h1></a>
<a class="header" href="print.html#wip-sync-arbiter" id="wip-sync-arbiter"><h1>[WIP] Sync arbiter</h1></a>
<a class="header" href="print.html#wip-stream" id="wip-stream"><h1>[WIP] Stream</h1></a>
<a class="header" href="print.html#wip-io-helpers" id="wip-io-helpers"><h1>[WIP] IO helpers</h1></a>
<a class="header" href="print.html#wip-supervisor" id="wip-supervisor"><h1>[WIP] Supervisor</h1></a>
<a class="header" href="print.html#wip-registry" id="wip-registry"><h1>[WIP] Registry</h1></a>
<a class="header" href="print.html#wip-helper-actors" id="wip-helper-actors"><h1>[WIP] Helper actors</h1></a>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>


        <!-- Local fallback for Font Awesome -->
        <script>
            if (getComputedStyle(document.querySelector(".fa")).fontFamily !== "FontAwesome") {
                var link = document.createElement('link');
                link.rel = 'stylesheet';
                link.type = 'text/css';
                link.href = '_FontAwesome/css/font-awesome.css';
                document.head.insertBefore(link, document.head.firstChild)
            }
        </script>

        

        
        <!-- Google Analytics Tag -->
        <script>
            var localAddrs = ["localhost", "127.0.0.1", ""];

            // make sure we don't activate google analytics if the developer is
            // inspecting the book locally...
            if (localAddrs.indexOf(document.location.hostname) === -1) {
                (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
                (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
                m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
                })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

                ga('create', 'UA-110322332-1', 'auto');
                ga('send', 'pageview');
            }
        </script>
        

        

        
        <script>
            document.addEventListener('DOMContentLoaded', function() {
                window.print();
            })
        </script>
        

        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS script -->
        

    </body>
</html>
